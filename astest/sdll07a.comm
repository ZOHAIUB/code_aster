# coding=utf-8
# --------------------------------------------------------------------
# Copyright (C) 1991 - 2025 - EDF R&D - www.code-aster.org
# This file is part of code_aster.
#
# code_aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# code_aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------

#####################################################################################
# CODE_ASTER COMMANDS FILE AUTOMATICALLY GENERATED BY PI, SALOME_MECA PIPING MODULE
#####################################################################################
import code_aster
from code_aster.Commands import *
import numpy as np
from code_aster import CA

test = CA.TestCase()

DEBUT(CODE="OUI")
# ------------------------------------------- PARAMETRES ----------------------------------------#
l_total = 10.0  # m : longueur totale de la poutre
nb_elem = int(20)  # intier, nombre des elements constitues de la poutre
x0 = 0.0  # coordonnee de la extremite gauche
VF = 10  # m/s
l_elem = l_total / nb_elem


L_groupma_poutre = []
L_groupno_poutre = []
for i in range(nb_elem):
    L_groupma_poutre.append("GEdge_%d" % i)
for i in range(nb_elem + 1):
    L_groupno_poutre.append("GVertex_%d" % i)

# MESH AND FE-MODEL DEFINITIONS ##########
MESH = LIRE_MAILLAGE(FORMAT="MED", INFO=2)
# MESH     = MODI_MAILLAGE(reuse    = MESH,
#                          MAILLAGE = MESH,
#                          ECHELLE  = 1.E-3,
#                          );
# regroupement
MESH = DEFI_GROUP(
    reuse=MESH, MAILLAGE=MESH, CREA_GROUP_MA=(_F(NOM="POUTRE", UNION=tuple(L_groupma_poutre)),)
)
# definir le groupe du noeud central
MESH = DEFI_GROUP(
    reuse=MESH,
    MAILLAGE=MESH,
    CREA_GROUP_NO=(
        _F(
            NOM="N_CENTRAL",
            OPTION="ENV_SPHERE",
            POINT=(l_total / 2.0, 0.0),
            RAYON=l_elem / 4.0,
            PRECISION=l_elem / 4.0,
        ),
    ),
)
# MODEL
MODEL = AFFE_MODELE(
    MAILLAGE=MESH,
    AFFE=(
        _F(GROUP_MA="POUTRE", PHENOMENE="MECANIQUE", MODELISATION="POU_D_T"),
        _F(GROUP_MA="GEdge_G", PHENOMENE="MECANIQUE", MODELISATION="DIS_TR"),
        _F(GROUP_MA="GEdge_D", PHENOMENE="MECANIQUE", MODELISATION="DIS_TR"),
    ),
)
#
# MATERIAL DEFINITIONS ##########
#
# MAT_1 : MAT_1 (Elastic)


MAT_1 = DEFI_MATERIAU(ELAS=_F(E=200.0 * 1.0e9, NU=0.3, RHO=8000.0))  # pa  # kg/m3
#
# ASSIGNING MATERIAL TO ELEMENTS ##########
MATER_F = AFFE_MATERIAU(MAILLAGE=MESH, AFFE=(_F(GROUP_MA="POUTRE", MATER=MAT_1),))
#
# FINITE ELEMENTS CARACTERISTICS (DIAMETER, THICKNESS) ##########
FE_CAR = AFFE_CARA_ELEM(
    MODELE=MODEL,
    POUTRE=(
        _F(
            GROUP_MA="POUTRE",
            SECTION="GENERALE",
            CARA=("A", "IY", "IZ", "JX", "AY", "AZ"),
            VALE=(
                12500.0 * 1.0e-6,  # A
                1e20 * 1.0e-12,  # IY
                # 5000000.0*1.E-12,            #IY
                5000000.0 * 1.0e-12,  # IZ    ==> le plus important
                # 1e+20*1.E-12,            #IZ
                2e20 * 1.0e-12,  # JX
                # 5000000.0*1E-12,            #JX
                # 1,                #AY
                1e-20,  # AY
                # 1,                #AZ
                1e-20,  # AZ
            ),
        ),
    ),
    COQUE=(),
    ORIENTATION=(),
    DISCRET=(
        _F(CARA="M_TR_D_L", GROUP_MA="GEdge_D", VALE=(0.0, 0.0, 0.0, 0.0)),
        _F(CARA="K_TR_D_L", GROUP_MA="GEdge_D", VALE=(0.0, 0.0, 0.0, 0.0, 0.0, 0.1)),
        _F(CARA="M_TR_D_L", GROUP_MA="GEdge_G", VALE=(0.0, 0.0, 0.0, 0.0)),
        _F(CARA="K_TR_D_L", GROUP_MA="GEdge_G", VALE=(100.0, 0.0, 0.0, 0.0, 0.0, 0.1)),
        # VALE     = (0.00000000000001, 0.0, 0.0, 0.0, 0.0, 0.0000000000001),),
    ),
)
#
# MECHANICAL BOUNDARY CONDITIONS ##########
BOUND_C = AFFE_CHAR_MECA(
    MODELE=MODEL,
    DDL_IMPO=(
        # _F(GROUP_NO = "ANCH_PT_5",
        # DX = 0., DY = 0., DZ = 0.,),
        # _F(GROUP_NO = "ANCH_PT_100",
        # DX = 0., DY = 0., DZ = 0.,),
        _F(GROUP_NO="GVertex_D", LIAISON="ENCASTRE"),
        _F(GROUP_NO="GVertex_G", LIAISON="ENCASTRE"),
        # _F(GROUP_NO = 'ANCH_PT_5',
        # LIAISON  = 'ENCASTRE'),
        # _F(GROUP_NO = 'ANCH_PT_100',
        # LIAISON  = 'ENCASTRE'),
        _F(GROUP_NO=L_groupno_poutre[0], DY=0.0, DZ=0.0, DRX=0.0, DRY=0.0),
        _F(GROUP_NO=L_groupno_poutre[-1], DX=0.0, DY=0.0, DZ=0.0, DRX=0.0, DRY=0.0),
    ),
    DDL_POUTRE=(),
    LIAISON_DDL=(),
    # THERMAL STRATIFICATION (FANNY)
    PRE_EPSI=(
        # KY and KZ are exchanged because of the local axis chosen (local Y and local Z are axchanged)
    ),
)
#
# EXTERNAL FORCES AND CHARGING #############
#
# list des chargement
List_EXCIT = []
List_EXCIT.append({"CHARGE": BOUND_C})
# List_EXCIT.append(_F(CHARGE    = BOUND_C,))

FOR = [None] * (nb_elem + 1)
FFOR = [None] * (nb_elem + 1)
for i in range(nb_elem + 1):
    xi = i * l_elem
    t1 = (xi - l_elem) / VF
    t2 = xi / VF
    t3 = (xi + l_elem) / VF
    groupno = L_groupno_poutre[i]
    FOR[i] = AFFE_CHAR_MECA(MODELE=MODEL, FORCE_NODALE=_F(GROUP_NO=groupno, FY=1.0))
    FFOR[i] = DEFI_FONCTION(
        NOM_PARA="INST",
        VALE=(t1, 0, t2, 48000, t3, 0),
        PROL_DROITE="CONSTANT",
        PROL_GAUCHE="CONSTANT",
    )
# append les charges
for i in range(nb_elem + 1):
    List_EXCIT.append({"CHARGE": FOR[i], "FONC_MULT": FFOR[i]})

# print(List_EXCIT)
# -----------------------------------------------------------------------------#
# ANALYSE MODALE
# -----------------------------------------------------------------------------#

masel = CALC_MATR_ELEM(
    OPTION="MASS_MECA", MODELE=MODEL, CHAM_MATER=MATER_F, CARA_ELEM=FE_CAR, CHARGE=BOUND_C
)
rigel = CALC_MATR_ELEM(
    OPTION="RIGI_MECA", MODELE=MODEL, CHAM_MATER=MATER_F, CARA_ELEM=FE_CAR, CHARGE=BOUND_C
)

NUM = NUME_DDL(MATR_RIGI=rigel)
rigi = ASSE_MATRICE(MATR_ELEM=rigel, NUME_DDL=NUM)
mass = ASSE_MATRICE(MATR_ELEM=masel, NUME_DDL=NUM)


MODES = CALC_MODES(
    MATR_RIGI=rigi,
    SOLVEUR_MODAL=_F(
        NMAX_ITER_SOREN=30,
        PREC_SOREN=0.0,
        PARA_ORTHO_SOREN=0.717,
        APPROCHE="REEL",
        METHODE="SORENSEN",
    ),
    MATR_MASS=mass,
    OPTION="BANDE",
    CALC_FREQ=_F(FREQ=(0.001, 1000.0)),
    NORM_MODE=_F(NORME="MASS_GENE"),
    # NORM_MODE=_F(NORME='TRAN_ROTA',),
    # FILTRE_MODE=_F(SEUIL=1e-04,),
    VERI_MODE=_F(STOP_ERREUR="NON"),
    IMPRESSION=_F(TOUT_PARA="OUI", CUMUL="OUI"),
)


# DYNA_VIBRA SOLVER ####################

lr = DEFI_LIST_REEL(DEBUT=0.0, INTERVALLE=(_F(JUSQU_A=1.0, PAS=0.01),))
# pour archiver
list_arc = DEFI_LIST_REEL(VALE=(0.1, 0.2, 0.5))


# lancer le calcul

dynline = DYNA_VIBRA(
    BASE_CALCUL="PHYS",
    TYPE_CALCUL="TRAN",
    MODELE=MODEL,
    CARA_ELEM=FE_CAR,
    CHAM_MATER=MATER_F,
    MATR_MASS=mass,
    MATR_RIGI=rigi,
    # MATR_AMOR    = amogene,
    AMOR_MODAL=_F(MODE_MECA=MODES, AMOR_REDUIT=0.001),
    SCHEMA_TEMPS=_F(
        SCHEMA=("NEWMARK",),
        # BETA    =0.25,
        # GAMMA    =0.50,
    ),
    # ETAT_INIT    = _F(
    # DEPL    =dep0,
    # VITE    =vit0,
    # ACCE    =acc0, if absence, acc0 = Fext(t=0) - Cv0-Ku0
    # ),
    EXCIT=(List_EXCIT),
    # MODE_CORR        =psmodes,
    INCREMENT=_F(LIST_INST=lr),
    ARCHIVAGE=(_F(LIST_INST=list_arc),),
    INFO=2,
)

dynline = CALC_CHAMP(
    reuse=dynline,
    MODELE=MODEL,
    CHAM_MATER=MATER_F,
    CARA_ELEM=FE_CAR,
    RESULTAT=dynline,
    CONTRAINTE=("EFGE_ELNO"),
)

## impression des resultats

RESU_5 = RECU_FONCTION(RESULTAT=dynline, NOM_CHAM="DEPL", NOM_CMP="DY", GROUP_NO="N_CENTRAL")

IMPR_FONCTION(FORMAT="TABLEAU", UNITE=98, COURBE=(_F(FONCTION=RESU_5),))
# ecrire sous format .mail
# IMPR_RESU(UNITE  = 99,
#          MODELE = MODEL,
#          FORMAT = 'ASTER',
#          #INFO=2,
#          RESU   = _F(MAILLAGE = MESH,
#                      ),);


# TEST_RESU
TEST_RESU(
    RESU=(
        _F(
            INST=0.1,
            NOM_CHAM="DEPL",
            NOM_CMP="DY",
            GROUP_NO="N_CENTRAL",
            RESULTAT=dynline,
            VALE_CALC=0.04051064431282782,
            VALE_REFE=0.04763,
            REFERENCE="SOURCE_EXTERNE",
            # REFERENCE='NON_DEFINI',
            CRITERE="RELATIF",
            PRECISION=0.1494735,
        ),
        _F(
            INST=0.2,
            NOM_CHAM="DEPL",
            NOM_CMP="DY",
            GROUP_NO="N_CENTRAL",
            RESULTAT=dynline,
            VALE_CALC=3.10240e-01,
            VALE_REFE=0.3235,
            REFERENCE="SOURCE_EXTERNE",
            CRITERE="RELATIF",
            PRECISION=0.0409895,
        ),
        _F(
            INST=0.5,
            NOM_CHAM="DEPL",
            NOM_CMP="DY",
            GROUP_NO="N_CENTRAL",
            RESULTAT=dynline,
            VALE_CALC=1.4462133418892895,
            VALE_REFE=1.4371,
            REFERENCE="SOURCE_EXTERNE",
            CRITERE="RELATIF",
            PRECISION=0.0064,
        ),
    )
)

# TEST FINAL DE LA METHODE computeMaxResultantForPipe avec les elements discrets

MAXABS_EFGE = dynline.getField("EFGE_ELNO", 1).toSimpleFieldOnCells()

components = ["N", "VY", "VZ", "MT", "MFY", "MFZ"]
component_index = {name: i for i, name in enumerate(components)}
comp_indices = [component_index[c] for c in components]
fields = [dynline.getField("EFGE_ELNO", p).toSimpleFieldOnCells() for p in dynline.getIndexes()]
nb_indx = len(fields)
arr = np.full((6, nb_indx), np.nan)
cells = MESH.getCells()

for cell in cells:
    npt = MAXABS_EFGE.getNumberOfPointsOfCell(cell)
    nspt = MAXABS_EFGE.getNumberOfSubPointsOfCell(cell)

    for ipt in range(npt):
        for ispt in range(nspt):
            arr[:] = np.nan
            for i in range(nb_indx):
                for j, comp in enumerate(comp_indices):
                    try:
                        arr[j, i] = fields[i].getValue(cell, comp, ipt, ispt)
                    except:
                        continue

            fx = np.abs(arr[0, :])
            fy = np.abs(arr[1, :])
            fz = np.abs(arr[2, :])
            moment = np.linalg.norm(arr[3:6, :], axis=0)
            moment[np.isnan(arr[3, :])] = np.nan

            max_fx, max_fy, max_fz = np.nanargmax(fx), np.nanargmax(fy), np.nanargmax(fz)
            val_fx, val_fy, val_fz = fx[max_fx], fy[max_fy], fz[max_fz]

            if np.all(np.isnan(moment)):
                moment_vec = np.full(3, np.nan)
            else:
                max_moment_idx = np.nanargmax(moment)
                moment_vec = np.abs(arr[3:6, max_moment_idx])

            MAXABS_EFGE.setValue(cell, component_index["N"], ipt, ispt, val_fx)
            MAXABS_EFGE.setValue(cell, component_index["VY"], ipt, ispt, val_fy)
            MAXABS_EFGE.setValue(cell, component_index["VZ"], ipt, ispt, val_fz)

            if not np.any(np.isnan(moment_vec)):
                for i, comp in enumerate(["MT", "MFY", "MFZ"]):
                    MAXABS_EFGE.setValue(cell, component_index[comp], ipt, ispt, moment_vec[i])

MAXABS_EFGE = MAXABS_EFGE.toFieldOnCells(MODEL.getFiniteElementDescriptor(), "EFGE_ELNO", "PEFFORR")

PhysProb = CA.PhysicalProblem(MODEL, MATER_F, FE_CAR)
MAXABS_EFGE_1 = CA.PostProcessing(PhysProb).computeMaxResultantForPipe(dynline, "EFGE_ELNO")
test.assertSequenceEqual(MAXABS_EFGE_1.getValues(), MAXABS_EFGE.getValues())

FIN()
